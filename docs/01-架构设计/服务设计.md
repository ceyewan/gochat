# 服务设计文档

## 服务概述

GoChat 系统包含四个核心服务，每个服务都有明确的职责和边界。

## im-gateway 服务设计

### 职责范围

- **客户端连接管理**: 维护 WebSocket 连接
- **消息路由**: 将消息路由到正确的目标
- **API 网关**: 提供 HTTP API 接口
- **负载均衡**: 分发客户端请求

### 接口设计

#### HTTP API

```go
// 用户认证
POST /api/v1/auth/login
POST /api/v1/auth/logout
POST /api/v1/auth/refresh

// 用户管理
POST /api/v1/users/register
GET  /api/v1/users/profile
PUT  /api/v1/users/profile

// 消息相关
POST /api/v1/messages/send
GET  /api/v1/messages/history
GET  /api/v1/messages/unread

// 会话相关
GET  /api/v1/conversations
POST /api/v1/conversations/create
PUT  /api/v1/conversations/{id}

// 群组相关
POST /api/v1/groups/create
GET  /api/v1/groups/{id}
POST /api/v1/groups/{id}/join
POST /api/v1/groups/{id}/leave
```

#### WebSocket 接口

```javascript
// 连接
ws://localhost:8080/ws?token={jwt_token}

// 消息格式
{
  "type": "message",
  "data": {
    "conversation_id": "conv_123",
    "content": "Hello World",
    "message_type": "text"
  }
}
```

### 数据结构

```go
type Client struct {
    ID         string
    UserID     string
    Connection *websocket.Conn
    Send       chan []byte
}

type GatewayServer struct {
    clients    map[string]*Client
    register   chan *Client
    unregister chan *Client
    broadcast  chan []byte
    kafkaProducer *kafka.Producer
    httpClient  *http.Client
}
```

### 关键流程

#### 1. 客户端连接流程

```go
func (s *GatewayServer) handleConnection(w http.ResponseWriter, r *http.Request) {
    // 1. 验证 JWT Token
    token := r.URL.Query().Get("token")
    userID, err := validateToken(token)
    
    // 2. 建立 WebSocket 连接
    conn, err := upgrader.Upgrade(w, r, nil)
    
    // 3. 创建客户端实例
    client := &Client{
        ID:         generateClientID(),
        UserID:     userID,
        Connection: conn,
        Send:       make(chan []byte, 256),
    }
    
    // 4. 注册客户端
    s.register <- client
    
    // 5. 启动读写协程
    go client.writePump()
    go client.readPump()
}
```

#### 2. 消息处理流程

```go
func (s *GatewayServer) handleMessage(client *Client, message []byte) {
    // 1. 解析消息
    var msg Message
    json.Unmarshal(message, &msg)
    
    // 2. 验证消息
    if err := validateMessage(&msg); err != nil {
        return
    }
    
    // 3. 发送到 Kafka
    kafkaMsg := &KafkaMessage{
        FromUserID:    client.UserID,
        ToUserID:      msg.ToUserID,
        ConversationID: msg.ConversationID,
        Content:       msg.Content,
        MessageType:   msg.MessageType,
        GatewayID:     s.gatewayID,
    }
    
    s.kafkaProducer.SendMessage("im-upstream-topic", kafkaMsg)
}
```

## im-logic 服务设计

### 职责范围

- **业务逻辑处理**: 处理核心业务逻辑
- **消息路由决策**: 决定消息路由策略
- **用户认证**: 验证用户身份
- **会话管理**: 管理会话状态
- **群组管理**: 管理群组相关功能

### gRPC 接口

```protobuf
service LogicService {
    // 认证相关
    rpc Authenticate(AuthRequest) returns (AuthResponse);
    rpc ValidateToken(ValidateTokenRequest) returns (ValidateTokenResponse);
    
    // 用户相关
    rpc GetUserProfile(GetUserProfileRequest) returns (GetUserProfileResponse);
    rpc UpdateUserProfile(UpdateUserProfileRequest) returns (UpdateUserProfileResponse);
    
    // 消息相关
    rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
    rpc GetMessageHistory(GetMessageHistoryRequest) returns (GetMessageHistoryResponse);
    rpc MarkMessageRead(MarkMessageReadRequest) returns (MarkMessageReadResponse);
    
    // 会话相关
    rpc CreateConversation(CreateConversationRequest) returns (CreateConversationResponse);
    rpc GetConversations(GetConversationsRequest) returns (GetConversationsResponse);
    rpc UpdateConversation(UpdateConversationRequest) returns (UpdateConversationResponse);
    
    // 群组相关
    rpc CreateGroup(CreateGroupRequest) returns (CreateGroupResponse);
    rpc GetGroupInfo(GetGroupInfoRequest) returns (GetGroupInfoResponse);
    rpc JoinGroup(JoinGroupRequest) returns (JoinGroupResponse);
    rpc LeaveGroup(LeaveGroupRequest) returns (LeaveGroupResponse);
    rpc AddGroupMember(AddGroupMemberRequest) returns (AddGroupMemberResponse);
    rpc RemoveGroupMember(RemoveGroupMemberRequest) returns (RemoveGroupMemberResponse);
}
```

### 服务结构

```go
type LogicServer struct {
    // gRPC 服务器
    grpcServer *grpc.Server
    
    // 依赖服务
    repoClient   pb.RepoServiceClient
    kafkaProducer *kafka.Producer
    kafkaConsumer *kafka.Consumer
    
    // 业务服务
    authService    *AuthService
    messageService  *MessageService
    conversationService *ConversationService
    groupService    *GroupService
    
    // 配置
    config *config.Config
}
```

### 关键流程

#### 1. 消息处理流程

```go
func (s *LogicServer) processMessage(ctx context.Context, msg *KafkaMessage) error {
    // 1. 验证发送者权限
    if err := s.authService.ValidateUser(ctx, msg.FromUserID); err != nil {
        return err
    }
    
    // 2. 检查会话权限
    if err := s.conversationService.CheckPermission(ctx, msg.FromUserID, msg.ConversationID); err != nil {
        return err
    }
    
    // 3. 处理消息内容
    processedMsg, err := s.messageService.ProcessMessage(ctx, msg)
    if err != nil {
        return err
    }
    
    // 4. 持久化消息（异步）
    go s.persistMessage(processedMsg)
    
    // 5. 路由消息
    if err := s.routeMessage(ctx, processedMsg); err != nil {
        return err
    }
    
    return nil
}
```

#### 2. 消息路由决策

```go
func (s *LogicServer) routeMessage(ctx context.Context, msg *ProcessedMessage) error {
    // 1. 获取会话信息
    conversation, err := s.conversationService.GetConversation(ctx, msg.ConversationID)
    if err != nil {
        return err
    }
    
    // 2. 根据会话类型路由
    switch conversation.Type {
    case ConversationTypeSingle:
        return s.routeSingleMessage(ctx, msg, conversation)
    case ConversationTypeGroup:
        return s.routeGroupMessage(ctx, msg, conversation)
    default:
        return errors.New("unknown conversation type")
    }
}
```

## im-repo 服务设计

### 职责范围

- **数据持久化**: 负责数据存储
- **数据查询**: 提供数据检索服务
- **事务管理**: 保证数据一致性
- **缓存管理**: 管理数据缓存

### gRPC 接口

```protobuf
service RepoService {
    // 用户相关
    rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
    rpc GetUser(GetUserRequest) returns (GetUserResponse);
    rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
    
    // 消息相关
    rpc CreateMessage(CreateMessageRequest) returns (CreateMessageResponse);
    rpc GetMessages(GetMessagesRequest) returns (GetMessagesResponse);
    rpc UpdateMessageStatus(UpdateMessageStatusRequest) returns (UpdateMessageStatusResponse);
    
    // 会话相关
    rpc CreateConversation(CreateConversationRequest) returns (CreateConversationResponse);
    rpc GetConversation(GetConversationRequest) returns (GetConversationResponse);
    rpc UpdateConversation(UpdateConversationRequest) returns (UpdateConversationResponse);
    
    // 群组相关
    rpc CreateGroup(CreateGroupRequest) returns (CreateGroupResponse);
    rpc GetGroup(GetGroupRequest) returns (GetGroupResponse);
    rpc UpdateGroup(UpdateGroupRequest) returns (UpdateGroupResponse);
    rpc AddGroupMember(AddGroupMemberRequest) returns (AddGroupMemberResponse);
    rpc RemoveGroupMember(RemoveGroupMemberRequest) returns (RemoveGroupMemberResponse);
}
```

### 数据库设计

```go
// 用户表
type User struct {
    ID        string    `gorm:"primary_key"`
    Username  string    `gorm:"unique;not null"`
    Email     string    `gorm:"unique;not null"`
    Password  string    `gorm:"not null"`
    Nickname  string    `gorm:"not null"`
    Avatar    string
    Status    int       `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}

// 消息表
type Message struct {
    ID             string    `gorm:"primary_key"`
    ConversationID string    `gorm:"not null"`
    FromUserID     string    `gorm:"not null"`
    ToUserID       string
    Content        string    `gorm:"type:text"`
    MessageType    string    `gorm:"not null"`
    Status         int       `gorm:"default:0"`
    CreatedAt      time.Time
    UpdatedAt      time.Time
}

// 会话表
type Conversation struct {
    ID          string    `gorm:"primary_key"`
    Type        string    `gorm:"not null"`
    Name        string
    Avatar      string
    LastMessage string
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

// 群组表
type Group struct {
    ID          string    `gorm:"primary_key"`
    Name        string    `gorm:"not null"`
    Description string
    Avatar      string
    OwnerID     string    `gorm:"not null"`
    MaxMembers  int       `gorm:"default:200"`
    CreatedAt   time.Time
    UpdatedAt   time.Time
}
```

### 关键流程

#### 1. 消息持久化

```go
func (s *RepoServer) CreateMessage(ctx context.Context, req *CreateMessageRequest) (*CreateMessageResponse, error) {
    // 1. 开启事务
    tx := s.db.Begin()
    
    // 2. 创建消息
    message := &Message{
        ID:             generateMessageID(),
        ConversationID: req.ConversationId,
        FromUserID:     req.FromUserId,
        ToUserID:       req.ToUserId,
        Content:        req.Content,
        MessageType:    req.MessageType,
        Status:         MessageStatusSent,
    }
    
    if err := tx.Create(message).Error; err != nil {
        tx.Rollback()
        return nil, err
    }
    
    // 3. 更新会话最后消息
    if err := tx.Model(&Conversation{}).
        Where("id = ?", req.ConversationId).
        Update("last_message", message.ID).Error; err != nil {
        tx.Rollback()
        return nil, err
    }
    
    // 4. 提交事务
    tx.Commit()
    
    // 5. 更新缓存
    s.cache.Delete(ctx, fmt.Sprintf("conversation:%s", req.ConversationId))
    
    return &CreateMessageResponse{
        MessageId: message.ID,
        Success:   true,
    }, nil
}
```

## im-task 服务设计

### 职责范围

- **大群消息扇出**: 处理大群消息的分发
- **消息持久化**: 异步消息持久化
- **离线推送**: 处理离线用户推送
- **异步任务**: 处理其他异步任务

### 服务结构

```go
type TaskServer struct {
    // Kafka 消费者
    groupMessageConsumer *kafka.Consumer
    persistenceConsumer  *kafka.Consumer
    
    // 依赖服务
    repoClient   pb.RepoServiceClient
    kafkaProducer *kafka.Producer
    
    // 任务处理器
    groupMessageHandler *GroupMessageHandler
    persistenceHandler  *PersistenceHandler
    pushHandler        *PushHandler
    
    // 配置
    config *config.Config
}
```

### 关键流程

#### 1. 大群消息扇出

```go
func (s *TaskServer) handleGroupMessage(ctx context.Context, msg *KafkaMessage) error {
    // 1. 获取群组信息
    group, err := s.repoClient.GetGroup(ctx, &pb.GetGroupRequest{
        GroupId: msg.ConversationID,
    })
    if err != nil {
        return err
    }
    
    // 2. 获取群组成员
    members, err := s.repoClient.GetGroupMembers(ctx, &pb.GetGroupMembersRequest{
        GroupId: msg.ConversationID,
    })
    if err != nil {
        return err
    }
    
    // 3. 批量处理成员
    batchSize := 100
    for i := 0; i < len(members.Members); i += batchSize {
        batch := members.Members[i:min(i+batchSize, len(members.Members))]
        go s.processMemberBatch(ctx, msg, batch)
    }
    
    return nil
}
```

#### 2. 消息持久化

```go
func (s *TaskServer) persistMessage(ctx context.Context, msg *KafkaMessage) error {
    // 1. 调用 im-repo 持久化消息
    _, err := s.repoClient.CreateMessage(ctx, &pb.CreateMessageRequest{
        ConversationId: msg.ConversationID,
        FromUserId:     msg.FromUserID,
        ToUserId:       msg.ToUserID,
        Content:        msg.Content,
        MessageType:    msg.MessageType,
    })
    
    if err != nil {
        log.Printf("Failed to persist message: %v", err)
        return err
    }
    
    // 2. 处理离线推送
    go s.handleOfflinePush(ctx, msg)
    
    return nil
}
```

## 服务间通信

### gRPC 通信

```go
// im-logic 调用 im-repo
repoClient, err := grpc.Dial("im-repo:9002", grpc.WithInsecure())
if err != nil {
    log.Fatal(err)
}

repoService := pb.NewRepoServiceClient(repoClient)

// 调用示例
user, err := repoService.GetUser(ctx, &pb.GetUserRequest{
    UserId: userID,
})
```

### Kafka 通信

```go
// 生产者配置
producer, err := kafka.NewProducer(&kafka.ConfigMap{
    "bootstrap.servers": "kafka:9092",
    "client.id":         "im-logic",
})

// 发送消息
producer.Produce(&kafka.Message{
    TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
    Value:          messageBytes,
}, nil)
```

## 错误处理

### 错误类型定义

```go
type ErrorCode int

const (
    ErrorCodeSuccess ErrorCode = 0
    ErrorCodeInvalidParams ErrorCode = 1001
    ErrorCodeUnauthorized ErrorCode = 1002
    ErrorCodeNotFound ErrorCode = 1003
    ErrorCodeInternalError ErrorCode = 1004
)

type Error struct {
    Code    ErrorCode
    Message string
    Details map[string]interface{}
}
```

### 错误处理策略

1. **参数验证**: 在服务入口处验证参数
2. **权限检查**: 在业务逻辑前检查权限
3. **事务处理**: 数据操作使用事务保证一致性
4. **错误传播**: 通过 gRPC status 传播错误
5. **错误日志**: 记录详细错误信息用于排查

## 性能优化

### 缓存策略

```go
// 多级缓存
type Cache struct {
    l1Cache *redis.Client  // 内存缓存
    l2Cache *redis.Client  // 分布式缓存
}

func (c *Cache) Get(ctx context.Context, key string) (interface{}, error) {
    // 先查 L1 缓存
    if val, err := c.l1Cache.Get(ctx, key).Result(); err == nil {
        return val, nil
    }
    
    // 再查 L2 缓存
    if val, err := c.l2Cache.Get(ctx, key).Result(); err == nil {
        // 回填 L1 缓存
        c.l1Cache.Set(ctx, key, val, time.Minute*5)
        return val, nil
    }
    
    return nil, errors.New("key not found")
}
```

### 数据库优化

1. **索引优化**: 为常用查询字段创建索引
2. **分页查询**: 大数据量使用分页查询
3. **连接池**: 配置合适的数据库连接池
4. **读写分离**: 读操作可以走从库

### 并发控制

```go
// 限流器
type RateLimiter struct {
    limiter *rate.Limiter
}

func (r *RateLimiter) Allow() bool {
    return r.limiter.Allow()
}

// 熔断器
type CircuitBreaker struct {
    failureCount int
    threshold    int
    state        string
}

func (c *CircuitBreaker) Call(fn func() error) error {
    if c.state == "open" {
        return errors.New("circuit breaker is open")
    }
    
    err := fn()
    if err != nil {
        c.failureCount++
        if c.failureCount >= c.threshold {
            c.state = "open"
            go c.resetAfterTimeout()
        }
    }
    
    return err
}
```